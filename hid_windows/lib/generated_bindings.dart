// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

class Api {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName) _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  Api(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  Api.fromLookup(ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName) lookup) : _lookup = lookup;

  /// @brief Initialize the HIDAPI library.
  ///
  /// This function initializes the HIDAPI library. Calling it is not
  /// strictly necessary, as it will be called automatically by
  /// hid_enumerate() and any of the hid_open_*() functions if it is
  /// needed.  This function should be called at the beginning of
  /// execution however, if there is a chance of HIDAPI handles
  /// being opened by different threads simultaneously.
  ///
  /// @ingroup API
  ///
  /// @returns
  /// This function returns 0 on success and -1 on error.
  int init() {
    return _init();
  }

  late final _initPtr = _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('hid_init');
  late final _init = _initPtr.asFunction<int Function()>();

  /// @brief Finalize the HIDAPI library.
  ///
  /// This function frees all of the static data associated with
  /// HIDAPI. It should be called at the end of execution to avoid
  /// memory leaks.
  ///
  /// @ingroup API
  ///
  /// @returns
  /// This function returns 0 on success and -1 on error.
  int exit() {
    return _exit();
  }

  late final _exitPtr = _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('hid_exit');
  late final _exit = _exitPtr.asFunction<int Function()>();

  /// @brief Enumerate the HID Devices.
  ///
  /// This function returns a linked list of all the HID devices
  /// attached to the system which match vendor_id and product_id.
  /// If @p vendor_id is set to 0 then any vendor matches.
  /// If @p product_id is set to 0 then any product matches.
  /// If @p vendor_id and @p product_id are both set to 0, then
  /// all HID devices will be returned.
  ///
  /// @ingroup API
  /// @param vendor_id The Vendor ID (VID) of the types of device
  /// to open.
  /// @param product_id The Product ID (PID) of the types of
  /// device to open.
  ///
  /// @returns
  /// This function returns a pointer to a linked list of type
  /// struct #hid_device_info, containing information about the HID devices
  /// attached to the system, or NULL in the case of failure. Free
  /// this linked list by calling hid_free_enumeration().
  ffi.Pointer<hid_device_info> enumerate(
    int vendor_id,
    int product_id,
  ) {
    return _enumerate(
      vendor_id,
      product_id,
    );
  }

  late final _enumeratePtr = _lookup<ffi.NativeFunction<ffi.Pointer<hid_device_info> Function(ffi.Uint16, ffi.Uint16)>>('hid_enumerate');
  late final _enumerate = _enumeratePtr.asFunction<ffi.Pointer<hid_device_info> Function(int, int)>();

  /// @brief Free an enumeration Linked List
  ///
  /// This function frees a linked list created by hid_enumerate().
  ///
  /// @ingroup API
  /// @param devs Pointer to a list of struct_device returned from
  /// hid_enumerate().
  void free_enumeration(
    ffi.Pointer<hid_device_info> devs,
  ) {
    return _free_enumeration(
      devs,
    );
  }

  late final _free_enumerationPtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<hid_device_info>)>>('hid_free_enumeration');
  late final _free_enumeration = _free_enumerationPtr.asFunction<void Function(ffi.Pointer<hid_device_info>)>();

  /// @brief Open a HID device using a Vendor ID (VID), Product ID
  /// (PID) and optionally a serial number.
  ///
  /// If @p serial_number is NULL, the first device with the
  /// specified VID and PID is opened.
  ///
  /// This function sets the return value of hid_error().
  ///
  /// @ingroup API
  /// @param vendor_id The Vendor ID (VID) of the device to open.
  /// @param product_id The Product ID (PID) of the device to open.
  /// @param serial_number The Serial Number of the device to open
  /// (Optionally NULL).
  ///
  /// @returns
  /// This function returns a pointer to a #hid_device object on
  /// success or NULL on failure.
  ffi.Pointer<hid_device> open(
    int vendor_id,
    int product_id,
    ffi.Pointer<wchar_t> serial_number,
  ) {
    return _open(
      vendor_id,
      product_id,
      serial_number,
    );
  }

  late final _openPtr = _lookup<ffi.NativeFunction<ffi.Pointer<hid_device> Function(ffi.Uint16, ffi.Uint16, ffi.Pointer<wchar_t>)>>('hid_open');
  late final _open = _openPtr.asFunction<ffi.Pointer<hid_device> Function(int, int, ffi.Pointer<wchar_t>)>();

  /// @brief Open a HID device by its path name.
  ///
  /// The path name be determined by calling hid_enumerate(), or a
  /// platform-specific path name can be used (eg: /dev/hidraw0 on
  /// Linux).
  ///
  /// This function sets the return value of hid_error().
  ///
  /// @ingroup API
  /// @param path The path name of the device to open
  ///
  /// @returns
  /// This function returns a pointer to a #hid_device object on
  /// success or NULL on failure.
  ffi.Pointer<hid_device> open_path(
    ffi.Pointer<ffi.Int8> path,
  ) {
    return _open_path(
      path,
    );
  }

  late final _open_pathPtr = _lookup<ffi.NativeFunction<ffi.Pointer<hid_device> Function(ffi.Pointer<ffi.Int8>)>>('hid_open_path');
  late final _open_path = _open_pathPtr.asFunction<ffi.Pointer<hid_device> Function(ffi.Pointer<ffi.Int8>)>();

  /// @brief Write an Output report to a HID device.
  ///
  /// The first byte of @p data[] must contain the Report ID. For
  /// devices which only support a single report, this must be set
  /// to 0x0. The remaining bytes contain the report data. Since
  /// the Report ID is mandatory, calls to hid_write() will always
  /// contain one more byte than the report contains. For example,
  /// if a hid report is 16 bytes long, 17 bytes must be passed to
  /// hid_write(), the Report ID (or 0x0, for devices with a
  /// single report), followed by the report data (16 bytes). In
  /// this example, the length passed in would be 17.
  ///
  /// hid_write() will send the data on the first OUT endpoint, if
  /// one exists. If it does not, it will send the data through
  /// the Control Endpoint (Endpoint 0).
  ///
  /// This function sets the return value of hid_error().
  ///
  /// @ingroup API
  /// @param dev A device handle returned from hid_open().
  /// @param data The data to send, including the report number as
  /// the first byte.
  /// @param length The length in bytes of the data to send.
  ///
  /// @returns
  /// This function returns the actual number of bytes written and
  /// -1 on error.
  int write(
    ffi.Pointer<hid_device> dev,
    ffi.Pointer<ffi.Uint8> data,
    int length,
  ) {
    return _write(
      dev,
      data,
      length,
    );
  }

  late final _writePtr = _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<hid_device>, ffi.Pointer<ffi.Uint8>, size_t)>>('hid_write');
  late final _write = _writePtr.asFunction<int Function(ffi.Pointer<hid_device>, ffi.Pointer<ffi.Uint8>, int)>();

  /// @brief Read an Input report from a HID device with timeout.
  ///
  /// Input reports are returned
  /// to the host through the INTERRUPT IN endpoint. The first byte will
  /// contain the Report number if the device uses numbered reports.
  ///
  /// This function sets the return value of hid_error().
  ///
  /// @ingroup API
  /// @param dev A device handle returned from hid_open().
  /// @param data A buffer to put the read data into.
  /// @param length The number of bytes to read. For devices with
  /// multiple reports, make sure to read an extra byte for
  /// the report number.
  /// @param milliseconds timeout in milliseconds or -1 for blocking wait.
  ///
  /// @returns
  /// This function returns the actual number of bytes read and
  /// -1 on error. If no packet was available to be read within
  /// the timeout period, this function returns 0.
  int read_timeout(
    ffi.Pointer<hid_device> dev,
    ffi.Pointer<ffi.Uint8> data,
    int length,
    int milliseconds,
  ) {
    return _read_timeout(
      dev,
      data,
      length,
      milliseconds,
    );
  }

  late final _read_timeoutPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<hid_device>, ffi.Pointer<ffi.Uint8>, size_t, ffi.Int32)>>('hid_read_timeout');
  late final _read_timeout = _read_timeoutPtr.asFunction<int Function(ffi.Pointer<hid_device>, ffi.Pointer<ffi.Uint8>, int, int)>();

  /// @brief Read an Input report from a HID device.
  ///
  /// Input reports are returned
  /// to the host through the INTERRUPT IN endpoint. The first byte will
  /// contain the Report number if the device uses numbered reports.
  ///
  /// This function sets the return value of hid_error().
  ///
  /// @ingroup API
  /// @param dev A device handle returned from hid_open().
  /// @param data A buffer to put the read data into.
  /// @param length The number of bytes to read. For devices with
  /// multiple reports, make sure to read an extra byte for
  /// the report number.
  ///
  /// @returns
  /// This function returns the actual number of bytes read and
  /// -1 on error. If no packet was available to be read and
  /// the handle is in non-blocking mode, this function returns 0.
  int read(
    ffi.Pointer<hid_device> dev,
    ffi.Pointer<ffi.Uint8> data,
    int length,
  ) {
    return _read(
      dev,
      data,
      length,
    );
  }

  late final _readPtr = _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<hid_device>, ffi.Pointer<ffi.Uint8>, size_t)>>('hid_read');
  late final _read = _readPtr.asFunction<int Function(ffi.Pointer<hid_device>, ffi.Pointer<ffi.Uint8>, int)>();

  /// @brief Set the device handle to be non-blocking.
  ///
  /// In non-blocking mode calls to hid_read() will return
  /// immediately with a value of 0 if there is no data to be
  /// read. In blocking mode, hid_read() will wait (block) until
  /// there is data to read before returning.
  ///
  /// Nonblocking can be turned on and off at any time.
  ///
  /// @ingroup API
  /// @param dev A device handle returned from hid_open().
  /// @param nonblock enable or not the nonblocking reads
  /// - 1 to enable nonblocking
  /// - 0 to disable nonblocking.
  ///
  /// @returns
  /// This function returns 0 on success and -1 on error.
  int set_nonblocking(
    ffi.Pointer<hid_device> dev,
    int nonblock,
  ) {
    return _set_nonblocking(
      dev,
      nonblock,
    );
  }

  late final _set_nonblockingPtr = _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<hid_device>, ffi.Int32)>>('hid_set_nonblocking');
  late final _set_nonblocking = _set_nonblockingPtr.asFunction<int Function(ffi.Pointer<hid_device>, int)>();

  /// @brief Send a Feature report to the device.
  ///
  /// Feature reports are sent over the Control endpoint as a
  /// Set_Report transfer.  The first byte of @p data[] must
  /// contain the Report ID. For devices which only support a
  /// single report, this must be set to 0x0. The remaining bytes
  /// contain the report data. Since the Report ID is mandatory,
  /// calls to hid_send_feature_report() will always contain one
  /// more byte than the report contains. For example, if a hid
  /// report is 16 bytes long, 17 bytes must be passed to
  /// hid_send_feature_report(): the Report ID (or 0x0, for
  /// devices which do not use numbered reports), followed by the
  /// report data (16 bytes). In this example, the length passed
  /// in would be 17.
  ///
  /// This function sets the return value of hid_error().
  ///
  /// @ingroup API
  /// @param dev A device handle returned from hid_open().
  /// @param data The data to send, including the report number as
  /// the first byte.
  /// @param length The length in bytes of the data to send, including
  /// the report number.
  ///
  /// @returns
  /// This function returns the actual number of bytes written and
  /// -1 on error.
  int send_feature_report(
    ffi.Pointer<hid_device> dev,
    ffi.Pointer<ffi.Uint8> data,
    int length,
  ) {
    return _send_feature_report(
      dev,
      data,
      length,
    );
  }

  late final _send_feature_reportPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<hid_device>, ffi.Pointer<ffi.Uint8>, size_t)>>('hid_send_feature_report');
  late final _send_feature_report = _send_feature_reportPtr.asFunction<int Function(ffi.Pointer<hid_device>, ffi.Pointer<ffi.Uint8>, int)>();

  /// @brief Get a feature report from a HID device.
  ///
  /// Set the first byte of @p data[] to the Report ID of the
  /// report to be read.  Make sure to allow space for this
  /// extra byte in @p data[]. Upon return, the first byte will
  /// still contain the Report ID, and the report data will
  /// start in data[1].
  ///
  /// This function sets the return value of hid_error().
  ///
  /// @ingroup API
  /// @param dev A device handle returned from hid_open().
  /// @param data A buffer to put the read data into, including
  /// the Report ID. Set the first byte of @p data[] to the
  /// Report ID of the report to be read, or set it to zero
  /// if your device does not use numbered reports.
  /// @param length The number of bytes to read, including an
  /// extra byte for the report ID. The buffer can be longer
  /// than the actual report.
  ///
  /// @returns
  /// This function returns the number of bytes read plus
  /// one for the report ID (which is still in the first
  /// byte), or -1 on error.
  int get_feature_report(
    ffi.Pointer<hid_device> dev,
    ffi.Pointer<ffi.Uint8> data,
    int length,
  ) {
    return _get_feature_report(
      dev,
      data,
      length,
    );
  }

  late final _get_feature_reportPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<hid_device>, ffi.Pointer<ffi.Uint8>, size_t)>>('hid_get_feature_report');
  late final _get_feature_report = _get_feature_reportPtr.asFunction<int Function(ffi.Pointer<hid_device>, ffi.Pointer<ffi.Uint8>, int)>();

  /// @brief Get a input report from a HID device.
  ///
  /// Set the first byte of @p data[] to the Report ID of the
  /// report to be read. Make sure to allow space for this
  /// extra byte in @p data[]. Upon return, the first byte will
  /// still contain the Report ID, and the report data will
  /// start in data[1].
  ///
  /// @ingroup API
  /// @param device A device handle returned from hid_open().
  /// @param data A buffer to put the read data into, including
  /// the Report ID. Set the first byte of @p data[] to the
  /// Report ID of the report to be read, or set it to zero
  /// if your device does not use numbered reports.
  /// @param length The number of bytes to read, including an
  /// extra byte for the report ID. The buffer can be longer
  /// than the actual report.
  ///
  /// @returns
  /// This function returns the number of bytes read plus
  /// one for the report ID (which is still in the first
  /// byte), or -1 on error.
  int get_input_report(
    ffi.Pointer<hid_device> dev,
    ffi.Pointer<ffi.Uint8> data,
    int length,
  ) {
    return _get_input_report(
      dev,
      data,
      length,
    );
  }

  late final _get_input_reportPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<hid_device>, ffi.Pointer<ffi.Uint8>, size_t)>>('hid_get_input_report');
  late final _get_input_report = _get_input_reportPtr.asFunction<int Function(ffi.Pointer<hid_device>, ffi.Pointer<ffi.Uint8>, int)>();

  /// @brief Close a HID device.
  ///
  /// This function sets the return value of hid_error().
  ///
  /// @ingroup API
  /// @param dev A device handle returned from hid_open().
  void close(
    ffi.Pointer<hid_device> dev,
  ) {
    return _close(
      dev,
    );
  }

  late final _closePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<hid_device>)>>('hid_close');
  late final _close = _closePtr.asFunction<void Function(ffi.Pointer<hid_device>)>();

  /// @brief Get The Manufacturer String from a HID device.
  ///
  /// @ingroup API
  /// @param dev A device handle returned from hid_open().
  /// @param string A wide string buffer to put the data into.
  /// @param maxlen The length of the buffer in multiples of wchar_t.
  ///
  /// @returns
  /// This function returns 0 on success and -1 on error.
  int get_manufacturer_string(
    ffi.Pointer<hid_device> dev,
    ffi.Pointer<wchar_t> string,
    int maxlen,
  ) {
    return _get_manufacturer_string(
      dev,
      string,
      maxlen,
    );
  }

  late final _get_manufacturer_stringPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<hid_device>, ffi.Pointer<wchar_t>, size_t)>>('hid_get_manufacturer_string');
  late final _get_manufacturer_string = _get_manufacturer_stringPtr.asFunction<int Function(ffi.Pointer<hid_device>, ffi.Pointer<wchar_t>, int)>();

  /// @brief Get The Product String from a HID device.
  ///
  /// @ingroup API
  /// @param dev A device handle returned from hid_open().
  /// @param string A wide string buffer to put the data into.
  /// @param maxlen The length of the buffer in multiples of wchar_t.
  ///
  /// @returns
  /// This function returns 0 on success and -1 on error.
  int get_product_string(
    ffi.Pointer<hid_device> dev,
    ffi.Pointer<wchar_t> string,
    int maxlen,
  ) {
    return _get_product_string(
      dev,
      string,
      maxlen,
    );
  }

  late final _get_product_stringPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<hid_device>, ffi.Pointer<wchar_t>, size_t)>>('hid_get_product_string');
  late final _get_product_string = _get_product_stringPtr.asFunction<int Function(ffi.Pointer<hid_device>, ffi.Pointer<wchar_t>, int)>();

  /// @brief Get The Serial Number String from a HID device.
  ///
  /// @ingroup API
  /// @param dev A device handle returned from hid_open().
  /// @param string A wide string buffer to put the data into.
  /// @param maxlen The length of the buffer in multiples of wchar_t.
  ///
  /// @returns
  /// This function returns 0 on success and -1 on error.
  int get_serial_number_string(
    ffi.Pointer<hid_device> dev,
    ffi.Pointer<wchar_t> string,
    int maxlen,
  ) {
    return _get_serial_number_string(
      dev,
      string,
      maxlen,
    );
  }

  late final _get_serial_number_stringPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<hid_device>, ffi.Pointer<wchar_t>, size_t)>>('hid_get_serial_number_string');
  late final _get_serial_number_string = _get_serial_number_stringPtr.asFunction<int Function(ffi.Pointer<hid_device>, ffi.Pointer<wchar_t>, int)>();

  /// @brief Get a string from a HID device, based on its string index.
  ///
  /// @ingroup API
  /// @param dev A device handle returned from hid_open().
  /// @param string_index The index of the string to get.
  /// @param string A wide string buffer to put the data into.
  /// @param maxlen The length of the buffer in multiples of wchar_t.
  ///
  /// @returns
  /// This function returns 0 on success and -1 on error.
  int get_indexed_string(
    ffi.Pointer<hid_device> dev,
    int string_index,
    ffi.Pointer<wchar_t> string,
    int maxlen,
  ) {
    return _get_indexed_string(
      dev,
      string_index,
      string,
      maxlen,
    );
  }

  late final _get_indexed_stringPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<hid_device>, ffi.Int32, ffi.Pointer<wchar_t>, size_t)>>('hid_get_indexed_string');
  late final _get_indexed_string = _get_indexed_stringPtr.asFunction<int Function(ffi.Pointer<hid_device>, int, ffi.Pointer<wchar_t>, int)>();

  /// @brief Get a string describing the last error which occurred.
  ///
  /// Whether a function sets the last error is noted in its
  /// documentation. These functions will reset the last error
  /// to NULL before their execution.
  ///
  /// Strings returned from hid_error() must not be freed by the user!
  ///
  /// This function is thread-safe, and error messages are thread-local.
  ///
  /// @ingroup API
  /// @param dev A device handle returned from hid_open(),
  /// or NULL to get the last non-device-specific error
  /// (e.g. for errors in hid_open() itself).
  ///
  /// @returns
  /// This function returns a string containing the last error
  /// which occurred or NULL if none has occurred.
  ffi.Pointer<wchar_t> error(
    ffi.Pointer<hid_device> dev,
  ) {
    return _error(
      dev,
    );
  }

  late final _errorPtr = _lookup<ffi.NativeFunction<ffi.Pointer<wchar_t> Function(ffi.Pointer<hid_device>)>>('hid_error');
  late final _error = _errorPtr.asFunction<ffi.Pointer<wchar_t> Function(ffi.Pointer<hid_device>)>();

  /// @brief Get a runtime version of the library.
  ///
  /// @ingroup API
  ///
  /// @returns
  /// Pointer to statically allocated struct, that contains version.
  ffi.Pointer<hid_api_version> version() {
    return _version();
  }

  late final _versionPtr = _lookup<ffi.NativeFunction<ffi.Pointer<hid_api_version> Function()>>('hid_version');
  late final _version = _versionPtr.asFunction<ffi.Pointer<hid_api_version> Function()>();

  /// @brief Get a runtime version string of the library.
  ///
  /// @ingroup API
  ///
  /// @returns
  /// Pointer to statically allocated string, that contains version string.
  ffi.Pointer<ffi.Int8> version_str() {
    return _version_str();
  }

  late final _version_strPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Int8> Function()>>('hid_version_str');
  late final _version_str = _version_strPtr.asFunction<ffi.Pointer<ffi.Int8> Function()>();
}

base class hid_api_version extends ffi.Struct {
  @ffi.Int32()
  external int major;

  @ffi.Int32()
  external int minor;

  @ffi.Int32()
  external int patch;
}

base class hid_device_ extends ffi.Opaque {}

/// hidapi info structure
base class hid_device_info extends ffi.Struct {
  /// Platform-specific device path
  external ffi.Pointer<ffi.Int8> path;

  /// Device Vendor ID
  @ffi.Uint16()
  external int vendor_id;

  /// Device Product ID
  @ffi.Uint16()
  external int product_id;

  /// Serial Number
  external ffi.Pointer<wchar_t> serial_number;

  /// Device Release Number in binary-coded decimal,
  /// also known as Device Version Number
  @ffi.Uint16()
  external int release_number;

  /// Manufacturer String
  external ffi.Pointer<wchar_t> manufacturer_string;

  /// Product string
  external ffi.Pointer<wchar_t> product_string;

  /// Usage Page for this Device/Interface
  /// (Windows/Mac/hidraw only)
  @ffi.Uint16()
  external int usage_page;

  /// Usage for this Device/Interface
  /// (Windows/Mac/hidraw only)
  @ffi.Uint16()
  external int usage;

  /// The USB interface which this logical device
  /// represents.
  ///
  /// Valid on both Linux implementations in all cases.
  /// Valid on the Windows implementation only if the device
  /// contains more than one interface.
  /// Valid on the Mac implementation if and only if the device
  /// is a USB HID device.
  @ffi.Int32()
  external int interface_number;

  /// Pointer to the next device
  external ffi.Pointer<hid_device_info> next;
}

typedef wchar_t = ffi.Uint16;
typedef hid_device = hid_device_;
typedef size_t = ffi.Uint64;

const int HID_API_VERSION_MAJOR = 0;

const int HID_API_VERSION_MINOR = 11;

const int HID_API_VERSION_PATCH = 0;

const String HID_API_VERSION_STR = '0.11.0';
